\subsection{Dependency injection} \label{sc:DependencyInjection}
Dependency injection is utilized to ensure a loose coupling between the classes, this is done by making all classes take interfaces in their constructor parameters, instead of concrete classes. On top of this any classes used in more than one location are instantiated in the program root, then a reference to the instance is transferred throughout the program. \\
To help explain Dependency Injection, an example from the program will be used.\\
Firstly the Class TagEditorViewModel:

\begin{code}
\begin{minted}
[frame=lines, framesep=1mm, baselinestretch=1.1, fontsize=\footnotesize, linenos]{csharp}

private ITagController _TagController;

 public TagEditorViewModel(ITagController tagController)
        {
    
    _TagController = tagController;
    
    //Do code, exempted from preview
}
\end{minted}
\captionof{listing}{TagEditorViewModel Example.}
\label{code:TagEditorViewModel}
\end{code}\vspace{\baselineskip}

As seen in \autoref{code:TagEditorViewModel} requires the interface \textit{ITagController}, in this case \textit{ITagController} is a controller that could be instantiated within \textit{TagEditorViewModel}, instead it is instantiated in the class calling \textit{TagEditorViewModel}, as a result of doing this, the specific implementation of \textit{ITagController} is irrelevant, as long as it implements the interface. \\
If the instantiation of a concrete class implementing the interface happened within \textit{TagEditorViewModel}, the \textit{TagEditorViewModel} would need to know the parameters of the class implementing \textit{ITagController}. \\
The result of this is a loose coupling between \textit{TagEditerViewModel} and \textit{ITagController}, as none of the classes rely on the specific implementation of the other class. \par

By implementing loose coupling it becomes easier to test different aspects of the program via Unit Testing, as the interfaces enables the use of mocks, stubs and fakes. \\
These are all ways of faking data that is not relevant for the current test. This makes the tests smaller and easier to verify, as they do not necessarily require interactions with the underlying data structures or database structures. Instead it allows for just faking an interface, and simply checking whether certain functions have been called as expected. \\
A description of how this is used in the project, is explained in \todo[inline]{Reference to TEST afsnittet}. \par
\todo{Write the stuff from the comments in the file}



%https://www.tutorialsteacher.com/ioc/dependency-injection

\par
%Makes it possible to have loose coupling\\
%Loose coupling in turn makes the code easier to test via the use of mocks/stubs/fakes\\
%Makes it easy to make code that follows the principles of SOLID\\
%Enables Open/closed by making Decorator pattern easy (bruger vi ikke)\\
%Decorator also makes single responsibility easier\\
%By depending on abstraction makes liskov substitution principle (Look it up) easy\\
        % http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
%Dependency inversion is the whole point\\
%Dependency inversion makes it easier/possible to to TDD\\
%Having object composition and lifetime elsewhere can increase maintainability\\
        % kilde: Dependency Injection Principles, practices, Patterns (Steven van Deursen & Mark seemann)
